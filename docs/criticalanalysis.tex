\chapter{Critical Analysis}

\section{General Comments}
Given the limited time that we were allocated for this project, the level of progression that has been made through the various stages of this project is really satisfying. The interpreter is essentially fully functional and the other two sections only have a few minor flaws to remedy. Not only has this project been a great aid to further our understanding in the Compilers field, but has also led to a greater appreciation of System Architecture. It is a shame that this project has been our only exposure to assembler during the course. There are some general comments that can be made regarding the state of the various parts of the compiler (in no particular order). 
\ \\ \ \\
Due to the size of the project and the number of implementation files, there will likely be some very small parts of code which were never used. The codebase has grown fairly large now and would probably benefit from being more rigorously documented to ensure that no functions exist that duplicate functionality of others or any that may never even be called.
\ \\ \ \\
Memory management is an area that would have to be looked at for this to ever transition into a serious compiler. The only place where memory is explicitly freed is where optimisations take place. With the limited use of a language without strings and a large standard library, it is difficult to see this becoming a problem in practice, but it still something to consider. Some of the functions, particularly those heavily used such as \verb!store()! in \verb!environment.c! are fairly unwieldy and have ended up with a multitude of different parameters for different contexts. Such large functions would be far clearer and thus less prone to bugs if they were rewritten and tested as smaller functions.
\ \\ \ \\
The coding standard is consistent throughout, all externally visible functions are declared in header files to try and give a greater sense of modularity. The code was compiled with the C89 (ANSI) and pedantic flags to try and clear up any non-standard code. While a test harness was developed for the generated programs, it would have also made sense to also look at testing the important functions within the coursework code itself to ensure that the functions all work as expected. In a few places within the project the \verb!assert()! function is used (defined in \verb!utilities.c!) to ensure that the internal state of the program is as expected. It would have been beneficial to introduce this to more places within the code.
\ \\ \ \\
Due to the number of different types of data that can be output by the various stages of the compiler, the use of \verb!var_args! was really beneficial in this project. Using \verb!var_args! means that commonly used functions such as \verb!fatal! and \verb!make_label_operand! are able to make use of variable numbers of arguments of varying types. This saves space and complexity by reducing the necessity of writing multiple ``type specific" functions.

\section{Interpreter}
The interpreter is the most functional part of the whole system, there are only two known issues. The first issue is that writing \verb!my_function(void)!, where the \verb!void! denotes no parameters, will parse correctly but is not interpreted. Unfortunately this issue was picked up fairly late, but it would be fairly trivial to fix. The parameter-list in these cases simply contains the integer ``void". A simple if statement could disregard this when storing the function in the environment.
\ \\ \ \\
The second issue is that although return values are type checked, no error is thrown if \textbf{no} value is returned and the function definition expects a value to be returned. The current behaviour is actually more like the behaviour in C. In order to implement similar behaviour to Java, it would be necessary to follow every possible branch to check that each branch returns a value.
\ \\ \ \\
The environment structure was created as part of the implementation of the interpreter. It uses a hash table implementation to minimise the cost of accessing and storing values within the environment. The environment has a lot of utility functions that are used through every part of the project. Unfortunately this utility is offset by quite a lot of complexity that is introduced through making these functions flexible.
\ \\ \ \\
Another good part of the implementation is that the interpreter has full type checking for both parameters and return values. The associated functions were purposely written so that they could be reused in other parts of the project. 
\section{TAC Generator}
The TAC Generator works for almost all of the test cases that were chosen. One issue with the TAC generator is that it does not accept input from standard input. This particular feature was alluded to in the coursework specification, but unfortunately not implemented due to time pressure. The only way to enter data into the TAC generator is via the parser. 
\ \\ \ \\
One of the main problems with the TAC generator at the moment is that it does not type check parameter values that are passed to functions. This means that some programs that are not accepted by the interpreter will be accepted by the TAC generator. This behaviour is obviously incorrect, but luckily the solution is already implemented in the interpreter. To fix this behaviour in the TAC generator, it would be a case of changing the \verb!push_params! procedure to take a reference to the callee function, so that the formal parameters can be compared to the actual parameters.
\ \\ \ \\
Some superfluous TAC instructions are present in the instruction set that are not used in the MIPS code generator (\verb!TT_FN_DEF!, \verb!TT_PREPARE!). The reason for this is that the TAC instruction set was developed prior to writing any of the code generator implementation. These additional instructions are not necessarily problematic as, in fact, they only serve to demonstrate the difference between what information is needed in each stage of the compiler. If further code generators were created for different architectures, they may benefit from these additional instructions, this is why these instructions have been left as part of the instruction set.
\ \\ \ \\
While the interpreter supports separate nested scopes within \verb!IF! and \verb!WHILE! statements, this functionality was not included in the TAC generator. This omission was an oversight and it was noted too late to include in the final code. Logically this feature is no more difficult to support in the TAC generator than in the interpreter.
\ \\ \ \\
Considering that the TAC instruction set was designed completely in advance of even researching MIPS, the instruction set has shown itself as ample to support the full code-generation procedure.

\section{MIPS Assembler Compiler}
While the MIPS code generator does have several weaknesses, it is actually very capable as demonstrated by the test results. As probably the most complicated part of the project, it is unsurprising that several problems exist within the implementation.
\ \\ \ \\
One issue with the MIPS code generation is that nested functions cannot share the same names, even if they reside in different scopes. The reason for this is that the user defined names are used to generate the function labels. If two functions have the same name, then they will produce the same function label. Obviously at run-time the processor will be unable to determine which one of the functions to invoke and a fatal error will be raised.
\ \\ \ \\
MIPS instructions are created within the code generator as a series of \verb!mips_instruction! structures. In order to create these structures, a helper function called \verb!mips! is provided. Because the \verb!mips! function caters for the definition of any valid MIPS instruction, the function contains many parameters and as a result, some very long lines. Because this function is used in many places within \verb!mips.c!, the whole file looks fairly untidy. To remedy this problem, it would be better to split the MIPS instruction set into different types of instruction, depending on the number and type of parameters that they cater for. This would enable much more compact \verb!mips_instruction! helper functions to be created.
\ \\ \ \\
Currently no analysis of basic blocks or functions is undertaken to ascertain what runtime support is needed. A lot more could be done to examine whether functions call other functions, whether they use function-typed variables, etc. This analysis would potentially mean that large amounts of code could removed. At the moment, every function has a complex activation record created upon function entry. If the function does not call another function and we have enough registers free, we could actually avoid creating an activation record at all. Additionally, some analysis could be done to ascertain how many registers are required by a function. If the function only requires one or two registers, then it may be possible to preserve all of the caller's registers, instead of writing them out into memory.
\ \\ \ \\
The reserved argument registers \$a0-\$a3 are also not used to pass the first four arguments. It was a shame that there was not time to implement this feature. We might even be able to save some activation record space if most of our arguments could fit into registers. At the moment, the code generator takes up a lot of space in the heap due to the number of Activation Records that are allocated. If this were being implemented in a real machine it would be necessary to use some type of garbage collection to reclaim the space that is allocated on the heap. Another waste in the code generator is that user program's are only able to use the \$t registers. Initially this was the case because the compiler needed to use some registers for certain operations. The solution will be discussed in the Further Improvements section.
\ \\ \ \\
The optimisation that is currently performed within \verb!optimisation.c! is used to remove redundant patterns of code. These fragments of code are introduced by exceptional cases that occur with certain inputs to the code generation procedure. Ideally some form of standard code optimisation would have been implemented, but unfortunately there was not enough time to fully research and implement these techniques. The basic optimisations that \textbf{are} provided show that such optimisation is possible and has been considered. 
\ \\ \ \\
A final problem with the code generation phase is that global variables do not work. The solution to this is also fairly simple and will be covered in the next section.
