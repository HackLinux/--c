\chapter{Further Improvements}

The critical analysis has highlighted some areas that could improved as part of a future project. This section will detail some of these ideas in further depth along with possible implementation approaches.

\section{Register Use}
One of the main criticisms surrounding the code generator are the register allocation choices that it makes. Currently it uses a version of a very simple approach that was discussed in lectures. Although this approach works, it generates code that would be many factors slower than a properly optimised program. Within the test cases, it is possible to see places where suboptimal decisions are made - for instance \verb!bigmath.c!, which was purposely designed to test register spills. Luckily, much research has been done into effective register allocation and there are documented methods such as graph colouring that aim to optimise the choices that are made at compile time. Although the graph colouring algorithm is generally an NP-complete problem, there are algorithms that are better in practice \cite{aho2007}.
\ \\ \ \\
The first step to improving the register allocation procedure is to implement a liveness check. This will enable us to make better decisions about which registers can be considered for reuse. A more comprehensive approach would be to implement a full graph colouring algorithm.
\ \\ \ \\
Currently, the compiler will only allow the \$t registers to be used for application data, because it reserves many of the \$s registers for its own use. Ideally, after a better register allocation procedure has been implemented, the compiler shouldn't need to \textbf{reserve} any registers. Instead, when the compiler needs to use a register, it can use the same register allocation procedure as followed for user data. This will ensure that more variables can be present in registers, which tends to lead to better optimised programs.
\section{TAC Parsing}
As noted in the document, it is currently not possible to load TAC instructions directly into the code generator. In order to implement this, a basic lexer would need to be written in order to generate the correct \verb!tac_quad! structures from the inputted file. Based on the instruction set that was presented in section \ref{sec:tacintro}, the input file could be examined line-by-line and split using whitespace characters as a delimiter. At this point we would be able to examine what type of instruction is being created and initialise the corresponding \verb!tac_quad! structure. In addition to this, we would need to fill the environment ``on the fly" as is currently done within the TAC generator. One problem with loading TAC instructions from a file, is that we have lost much of the type information that is given to us by the original environment structure. This would make it impossible to perform type checking without rewriting the instruction set to provide this information.

\section{Optimisation}
As a further extension to the submitted code, it would be good to look at partitioning the code into basic blocks. Once the code is in basic blocks, it is possible to optimise the blocks as if they were individual programs. Although some basic optimisations exist in \verb!optimisation.c!, these operate on the generated MIPS code. Most of the genuinely helpful optimisations occur during the TAC generation stage over a basic block. The ``copy propagation" optimisation would be particularly beneficial for some of the code that is generated by the TAC generator. As discussed in tests such as \verb!indirection.c!, return values from function calls are typically stored in a temporary and then assigned straight into another variable. The ``copy propagation" optimisation would eliminate redundant code like this.
\ \\ \ \\
Another optimisation technique ``constant propagation" could be used to reduce simple arithmetic calculations, such as those in \verb!bigmath.c!, at compile time. For a limited language like \mmc, this type of optimisation is likely to have a great effect, as most example scripts tend to rely on arithmetic.
\ \\ \ \\
Upon splitting the program up into basic blocks, there will be situations where whole blocks of code can be removed. The definitions of functions which are not even used are currently translated into MIPS code. Also, \verb!IF! statements which branch on constants / variables, such as in \verb!iftest.c! could also be hugely simplified using a similar procedure.

\section{Supporting Global Variables}
In order to support global variables in the code generation phase, it would be necessary to re-create the idea of a ``global environment" in the code generator. To do this, the global environment would be found and the number of local variables would be checked. Within the main method, a space would be allocated within the heap of the required size. When looping over the \verb!tac_quad!s, if we see a variable assignment and we are not within an function, then the variable could be added to the correct place within the global environment.